{"version":3,"sources":["../ES2015/algorithms/poissonDisk.js"],"names":["PoissonDiskSampler","width","height","pointList","maxPoints","pi2","Math","PI","w","h","distanceMap","excludeMap","excludeThreshold","nr","pp","radiusmin","radiusmax","type","imgw","imgh","numFailed","maxFails","createfirstPointPerso","generateRandomAroundPerso","hitTest","radiusMin","radiusMax","ranX","parseInt","random","ranY","radius","p","getHitMapPixel","x","y","r","t","p_point","ran","a","newX","newY","sin","cos","createfirstPoint","generateRandomAround","getExcludeMapPixel","l","length","d","dx","dy","i","pTemp","sqrt","p_x","p_y","getImageData","data"],"mappings":"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","file":"poissonDisk.js","sourcesContent":["/**\n * Created by Thierry Hubmann\n * Ré-implémentation de la classe PoissonDisk implémentée par Marcel en ES2015 pour la rendre\n * compatible avec la nouvelle classe graphGenerationUtil.\n */\nclass PoissonDiskSampler {\n\n    constructor(width, height) {\n        // Coordonnées des points sur la surface\n        this.pointList = [];\n        // Nombre de points maximum sur la surface\n        this.maxPoints = 100;\n\n        this.pi2 = Math.PI * 2;\n        this.w = width;\n        this.h = height;\n        this.distanceMap = null;\n        this.excludeMap = null;\n        this.excludeThreshold = 0;\n\n        this.nr = 0;\n        this.pp = null;\n    }\n\n    /* créé un point au hasard\n     * @params radiusmin : rayon de la distance minimum\n     *         radiusmax : rayon de la distance maximum\n     *         type : nom de l'image. Ne sert pas au calcul des points\n     *         imgw : largeur de l'image. ne sert pas au calcul des points\n     *         imgh : hauteur de l'image. ne sert pas au calcul des points\n     * €returns\n     */\n    createPointsPerso(radiusmin, radiusmax, type, imgw, imgh) {\n        var numFailed = 0;\n        var maxFails = 500;\n        do {\n            if (this.nr === 0) { // Si aucun point n'existe on en créé un\n                this.pp = this.createfirstPointPerso(radiusmin, radiusmax, type, imgw, imgh);\n            } else { // Sinon on créé des points autour\n                this.pp = this.generateRandomAroundPerso(this.pp, radiusmin, radiusmax, type, imgw, imgh);\n            }\n            // sert à voir si le point en touche un autre\n            if (this.hitTest(this.pp)) {\n                this.pointList[this.nr] = this.pp;\n                this.nr++;\n                numFailed = 0;\n            } else {\n                numFailed++;\n            }\n        } while (numFailed > 0 && numFailed < maxFails);\n    }\n\n    /* créé le premier  point au hasard\n     * @params radiusmin : rayon de la distance minimum\n     *         radiusmax : rayon de la distance maximum\n     *         type : nom de l'image. Ne sert pas au calcul des points\n     *         imgw : largeur de l'image. ne sert pas au calcul des points\n     *         imgh : hauteur de l'image. ne sert pas au calcul des points\n     * €returns x : position x\n     *          y : position y\n     *          r : rayon de l'image\n     *          t : nom de l'image\n     *          w : largeur de l'image\n     *          h : hauteur de l'image\n     */\n    createfirstPointPerso(radiusMin, radiusMax, type, imgw, imgh) {\n        var ranX = parseInt(Math.random() * this.w, 10),\n            ranY = parseInt(Math.random() * this.h, 10),\n            radius;\n\n        if (this.distanceMap === null) {\n            radius = parseInt(radiusMin + (Math.random() * (radiusMax - radiusMin)), 10);\n        } else {\n            var p = this.getHitMapPixel(ranX, ranY);\n            radius = radiusMin + ((radiusMax - radiusMin) * (p[0] / 255));\n        }\n        return {x: ranX, y: ranY, r: radius, t: type, w: imgw, h: imgh};\n    }\n\n    /* créé un point au hasard\n     * @params radiusmin : rayon de la distance minimum\n     *         radiusmax : rayon de la distance maximum\n     *         type : nom de l'image. Ne sert pas au calcul des points\n     *         imgw : largeur de l'image. ne sert pas au calcul des points\n     *         imgh : hauteur de l'image. ne sert pas au calcul des points\n     * €returns x : position x\n     *          y : position y\n     *          r : rayon de l'image\n     *          t : nom de l'image\n     *          w : largeur de l'image\n     *          h : hauteur de l'image\n     */\n\tgenerateRandomAroundPerso(p_point, radiusMin, radiusMax, type, imgw, imgh) {\n\t\tvar ran,\n\t\t\tradius,\n\t\t\ta,\n\t\t\tnewX,\n\t\t\tnewY;\n\n\t\tran = Math.random();\n\t\tradius = parseInt(p_point.r + radiusMax * (ran), 10);\n\t\ta = this.pi2 * (ran);\n\t\tnewX = parseInt(p_point.x + (radius * Math.sin(a)), 10);\n\t\tnewY = parseInt(p_point.y + (radius * Math.cos(a)), 10);\n\n\t\tif (newX <= 0 || newX >= this.w) {\n\t\t\tnewX = parseInt(ran * this.w, 10);\n\t\t}\n\n\t\tif (newY <= 0 || newY >= this.h) {\n\t\t\tnewY = parseInt(ran * this.h, 10);\n\t\t}\n\n\t\tif (this.distanceMap === null) {\n\t\t\tradius = radiusMin + (Math.random() * (radiusMax - radiusMin));\n\t\t} else {\n\t\t\t// red color\n\t\t\tvar p = this.getHitMapPixel(newX, newY);\n\t\t\tradius = radiusMin + ((radiusMax - radiusMin) * (p[0] / 255));\n\t\t}\n\n\t\treturn {\n\t\t\tx : newX,\n\t\t\ty : newY,\n\t\t\tr : radius,\n\t\t\tt : type,\n            w : imgw,\n            h : imgh\n\t\t};\n\t}\n\n    // créé un point au hasard sur la carte\n\tcreatePoints() {\n\t\tvar nr = 0,\n\t\t\tpp,\n\t\t\tnumFailed = 0;\n\n\t\twhile (nr < this.maxPoints && numFailed < this.maxFails) {\n\t\t\tif (nr === 0) {\n\t\t\t\tpp = this.createfirstPoint();\n\t\t\t} else {\n\t\t\t\tpp = this.generateRandomAround(pp);\n\t\t\t}\n\n\t\t\tif (this.hitTest(pp)) {\n\t\t\t\tthis.pointList[nr] = pp;\n\t\t\t\tnr++;\n\t\t\t\tnumFailed = 0;\n\t\t\t} else {\n\t\t\t\tnumFailed++;\n\t\t\t}\n\t\t}\n\t}\n\n    // regarde si le point créé touche un autre point\n\thitTest(p_point) {\n\t\tif( this.excludeMap !== null ) {\n\t\t\tvar p = this.getExcludeMapPixel(p_point.x, p_point.y);\n\t\t\tif(p[0] <= this.excludeThreshold) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tvar l = this.pointList.length,\n\t\t\td = 0,\n\t\t\tdx = 0,\n\t\t\tdy = 0,\n\t\t\ti = l,\n\t\t\tpTemp;\n\n\t\tif (l > 0) {\n\t\t\twhile (i--) {\n\t\t\t\tpTemp = this.pointList[i];\n\t\t\t\tdx = pTemp.x - p_point.x;\n\t\t\t\tdy = pTemp.y - p_point.y;\n\t\t\t\td = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tif (d <= (pTemp.r + p_point.r)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n    createfirstPoint() {\n\t\tvar ranX = parseInt(Math.random() * this.w, 10),\n\t\t\tranY = parseInt(Math.random() * this.h, 10),\n\t\t\tradius;\n\n\t\tif (this.distanceMap === null) {\n\t\t\tradius = parseInt(this.radiusMin + (Math.random() * (this.radiusMax - this.radiusMin)),10);\n\t\t} else {\n\t\t\tvar p = this.getHitMapPixel(ranX, ranY);\n\t\t\tradius = this.radiusMin + ((this.radiusMax - this.radiusMin) * (p[0] / 255));\n\t\t}\n\t\treturn {x:ranX, y:ranY, r:radius};\n\t}\n\n\tgetExcludeMapPixel(p_x, p_y) {\n\t\treturn this.excludeMap.getImageData(p_x, p_y, 1, 1).data;\n\t}\n\n\tgetHitMapPixel(p_x, p_y) {\n\t\treturn this.distanceMap.getImageData(p_x, p_y, 1, 1).data;\n\t}\n\n\tgenerateRandomAround(p_point) {\n\t\tvar ran,\n\t\t\tradius,\n\t\t\ta,\n\t\t\tnewX,\n\t\t\tnewY;\n\n\t\tran = Math.random();\n\t\tradius = parseInt(p_point.r + this.radiusMax * (ran), 10);\n\t\ta = this.pi2 * (ran);\n\t\tnewX = parseInt(p_point.x + (radius * Math.sin(a)), 10);\n\t\tnewY = parseInt(p_point.y + (radius * Math.cos(a)), 10);\n\n\t\tif (newX <= 0 || newX >= this.w) {\n\t\t\tnewX = parseInt(ran * this.w, 10);\n\t\t}\n\n\t\tif (newY <= 0 || newY >= this.h) {\n\t\t\tnewY = parseInt(ran * this.h, 10);\n\t\t}\n\n\t\tif (this.distanceMap === null) {\n\t\t\tradius = this.radiusMin + (Math.random() * (this.radiusMax - this.radiusMin));\n\t\t} else {\n\t\t\t// red color\n\t\t\tvar p = this.getHitMapPixel(newX, newY);\n\t\t\tradius = this.radiusMin + ((this.radiusMax - this.radiusMin) * (p[0] / 255));\n\t\t}\n\n\t\treturn {\n\t\t\tx : newX,\n\t\t\ty : newY,\n\t\t\tr : radius\n\t\t};\n\t}\n}\n\nexport{PoissonDiskSampler};"]}