{"version":3,"sources":["../ES2015/algorithms/poissonDisk.js"],"names":["PoissonDiskSampler","width","height","pointList","maxPoints","pi2","Math","PI","w","h","distanceMap","excludeMap","excludeThreshold","nr","pp","radiusmin","radiusmax","type","imgw","imgh","numFailed","maxFails","createfirstPointPerso","generateRandomAroundPerso","hitTest","radiusMin","radiusMax","ranX","parseInt","random","ranY","radius","p","getHitMapPixel","x","y","r","t","p_point","ran","a","newX","newY","sin","cos","createfirstPoint","generateRandomAround","getExcludeMapPixel","l","length","d","dx","dy","i","pTemp","sqrt","p_x","p_y","getImageData","data"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAKMA,kB;AAEF,oCAAYC,KAAZ,EAAmBC,MAAnB,EAA2B;AAAA;;AACvB;AACA,iBAAKC,SAAL,GAAiB,EAAjB;AACA;AACA,iBAAKC,SAAL,GAAiB,GAAjB;;AAEA,iBAAKC,GAAL,GAAWC,KAAKC,EAAL,GAAU,CAArB;AACA,iBAAKC,CAAL,GAASP,KAAT;AACA,iBAAKQ,CAAL,GAASP,MAAT;AACA,iBAAKQ,WAAL,GAAmB,IAAnB;AACA,iBAAKC,UAAL,GAAkB,IAAlB;AACA,iBAAKC,gBAAL,GAAwB,CAAxB;;AAEA,iBAAKC,EAAL,GAAU,CAAV;AACA,iBAAKC,EAAL,GAAU,IAAV;AACH;;AAED;;;;;;;;;;;;8CAQkBC,S,EAAWC,S,EAAWC,I,EAAMC,I,EAAMC,I,EAAM;AACtD,oBAAIC,YAAY,CAAhB;AACA,oBAAIC,WAAW,GAAf;AACA,mBAAG;AACC,wBAAI,KAAKR,EAAL,KAAY,CAAhB,EAAmB;AAAE;AACjB,6BAAKC,EAAL,GAAU,KAAKQ,qBAAL,CAA2BP,SAA3B,EAAsCC,SAAtC,EAAiDC,IAAjD,EAAuDC,IAAvD,EAA6DC,IAA7D,CAAV;AACH,qBAFD,MAEO;AAAE;AACL,6BAAKL,EAAL,GAAU,KAAKS,yBAAL,CAA+B,KAAKT,EAApC,EAAwCC,SAAxC,EAAmDC,SAAnD,EAA8DC,IAA9D,EAAoEC,IAApE,EAA0EC,IAA1E,CAAV;AACH;AACD;AACA,wBAAI,KAAKK,OAAL,CAAa,KAAKV,EAAlB,CAAJ,EAA2B;AACvB,6BAAKX,SAAL,CAAe,KAAKU,EAApB,IAA0B,KAAKC,EAA/B;AACA,6BAAKD,EAAL;AACAO,oCAAY,CAAZ;AACH,qBAJD,MAIO;AACHA;AACH;AACJ,iBAdD,QAcSA,YAAY,CAAZ,IAAiBA,YAAYC,QAdtC;AAeH;;;kDAeqBI,S,EAAWC,S,EAAWT,I,EAAMC,I,EAAMC,I,EAAM;AAC1D,oBAAIQ,OAAOC,SAAStB,KAAKuB,MAAL,KAAgB,KAAKrB,CAA9B,EAAiC,EAAjC,CAAX;AAAA,oBACIsB,OAAOF,SAAStB,KAAKuB,MAAL,KAAgB,KAAKpB,CAA9B,EAAiC,EAAjC,CADX;AAAA,oBAEIsB,MAFJ;;AAIA,oBAAI,KAAKrB,WAAL,KAAqB,IAAzB,EAA+B;AAC3BqB,6BAASH,SAASH,YAAanB,KAAKuB,MAAL,MAAiBH,YAAYD,SAA7B,CAAtB,EAAgE,EAAhE,CAAT;AACH,iBAFD,MAEO;AACH,wBAAIO,IAAI,KAAKC,cAAL,CAAoBN,IAApB,EAA0BG,IAA1B,CAAR;AACAC,6BAASN,YAAa,CAACC,YAAYD,SAAb,KAA2BO,EAAE,CAAF,IAAO,GAAlC,CAAtB;AACH;AACD,uBAAO,EAACE,GAAGP,IAAJ,EAAUQ,GAAGL,IAAb,EAAmBM,GAAGL,MAAtB,EAA8BM,GAAGpB,IAAjC,EAAuCT,GAAGU,IAA1C,EAAgDT,GAAGU,IAAnD,EAAP;AACH;;;sDAeyBmB,O,EAASb,S,EAAWC,S,EAAWT,I,EAAMC,I,EAAMC,I,EAAM;AACvE,oBAAIoB,GAAJ,EACIR,MADJ,EAEIS,CAFJ,EAGIC,IAHJ,EAIIC,IAJJ;;AAMAH,sBAAMjC,KAAKuB,MAAL,EAAN;AACAE,yBAASH,SAASU,QAAQF,CAAR,GAAYV,YAAaa,GAAlC,EAAwC,EAAxC,CAAT;AACAC,oBAAI,KAAKnC,GAAL,GAAYkC,GAAhB;AACAE,uBAAOb,SAASU,QAAQJ,CAAR,GAAaH,SAASzB,KAAKqC,GAAL,CAASH,CAAT,CAA/B,EAA6C,EAA7C,CAAP;AACAE,uBAAOd,SAASU,QAAQH,CAAR,GAAaJ,SAASzB,KAAKsC,GAAL,CAASJ,CAAT,CAA/B,EAA6C,EAA7C,CAAP;;AAEA,oBAAIC,QAAQ,CAAR,IAAaA,QAAQ,KAAKjC,CAA9B,EAAiC;AAC7BiC,2BAAOb,SAASW,MAAM,KAAK/B,CAApB,EAAuB,EAAvB,CAAP;AACH;;AAED,oBAAIkC,QAAQ,CAAR,IAAaA,QAAQ,KAAKjC,CAA9B,EAAiC;AAC7BiC,2BAAOd,SAASW,MAAM,KAAK9B,CAApB,EAAuB,EAAvB,CAAP;AACH;;AAED,oBAAI,KAAKC,WAAL,KAAqB,IAAzB,EAA+B;AAC3BqB,6BAASN,YAAanB,KAAKuB,MAAL,MAAiBH,YAAYD,SAA7B,CAAtB;AACH,iBAFD,MAEO;AACH;AACA,wBAAIO,IAAI,KAAKC,cAAL,CAAoBQ,IAApB,EAA0BC,IAA1B,CAAR;AACAX,6BAASN,YAAa,CAACC,YAAYD,SAAb,KAA2BO,EAAE,CAAF,IAAO,GAAlC,CAAtB;AACH;;AAED,uBAAO;AACHE,uBAAGO,IADA;AAEHN,uBAAGO,IAFA;AAGHN,uBAAGL,MAHA;AAIHM,uBAAGpB,IAJA;AAKHT,uBAAGU,IALA;AAMHT,uBAAGU;AANA,iBAAP;AAQH;;;2CAGc;AACX,oBAAIN,KAAK,CAAT;AAAA,oBACIC,EADJ;AAAA,oBAEIM,YAAY,CAFhB;;AAIA,uBAAOP,KAAK,KAAKT,SAAV,IAAuBgB,YAAY,KAAKC,QAA/C,EAAyD;AACrD,wBAAIR,OAAO,CAAX,EAAc;AACVC,6BAAK,KAAK+B,gBAAL,EAAL;AACH,qBAFD,MAEO;AACH/B,6BAAK,KAAKgC,oBAAL,CAA0BhC,EAA1B,CAAL;AACH;;AAED,wBAAI,KAAKU,OAAL,CAAaV,EAAb,CAAJ,EAAsB;AAClB,6BAAKX,SAAL,CAAeU,EAAf,IAAqBC,EAArB;AACAD;AACAO,oCAAY,CAAZ;AACH,qBAJD,MAIO;AACHA;AACH;AACJ;AACJ;;;oCAGOkB,O,EAAS;AACb,oBAAI,KAAK3B,UAAL,KAAoB,IAAxB,EAA8B;AAC1B,wBAAIqB,IAAI,KAAKe,kBAAL,CAAwBT,QAAQJ,CAAhC,EAAmCI,QAAQH,CAA3C,CAAR;AACA,wBAAIH,EAAE,CAAF,KAAQ,KAAKpB,gBAAjB,EAAmC;AAC/B,+BAAO,KAAP;AACH;AACJ;;AAED,oBAAIoC,IAAI,KAAK7C,SAAL,CAAe8C,MAAvB;AAAA,oBACIC,IAAI,CADR;AAAA,oBAEIC,KAAK,CAFT;AAAA,oBAGIC,KAAK,CAHT;AAAA,oBAIIC,IAAIL,CAJR;AAAA,oBAKIM,KALJ;;AAOA,oBAAIN,IAAI,CAAR,EAAW;AACP,2BAAOK,GAAP,EAAY;AACRC,gCAAQ,KAAKnD,SAAL,CAAekD,CAAf,CAAR;AACAF,6BAAKG,MAAMpB,CAAN,GAAUI,QAAQJ,CAAvB;AACAkB,6BAAKE,MAAMnB,CAAN,GAAUG,QAAQH,CAAvB;AACAe,4BAAI5C,KAAKiD,IAAL,CAAUJ,KAAKA,EAAL,GAAUC,KAAKA,EAAzB,CAAJ;;AAEA,4BAAIF,KAAMI,MAAMlB,CAAN,GAAUE,QAAQF,CAA5B,EAAgC;AAC5B,mCAAO,KAAP;AACH;AACJ;AACJ;;AAED,uBAAO,IAAP;AACH;;;+CAEkB;AACf,oBAAIT,OAAOC,SAAStB,KAAKuB,MAAL,KAAgB,KAAKrB,CAA9B,EAAiC,EAAjC,CAAX;AAAA,oBACIsB,OAAOF,SAAStB,KAAKuB,MAAL,KAAgB,KAAKpB,CAA9B,EAAiC,EAAjC,CADX;AAAA,oBAEIsB,MAFJ;;AAIA,oBAAI,KAAKrB,WAAL,KAAqB,IAAzB,EAA+B;AAC3BqB,6BAASH,SAAS,KAAKH,SAAL,GAAkBnB,KAAKuB,MAAL,MAAiB,KAAKH,SAAL,GAAiB,KAAKD,SAAvC,CAA3B,EAA+E,EAA/E,CAAT;AACH,iBAFD,MAEO;AACH,wBAAIO,IAAI,KAAKC,cAAL,CAAoBN,IAApB,EAA0BG,IAA1B,CAAR;AACAC,6BAAS,KAAKN,SAAL,GAAkB,CAAC,KAAKC,SAAL,GAAiB,KAAKD,SAAvB,KAAqCO,EAAE,CAAF,IAAO,GAA5C,CAA3B;AACH;AACD,uBAAO,EAACE,GAAGP,IAAJ,EAAUQ,GAAGL,IAAb,EAAmBM,GAAGL,MAAtB,EAAP;AACH;;;+CAEkByB,G,EAAKC,G,EAAK;AACzB,uBAAO,KAAK9C,UAAL,CAAgB+C,YAAhB,CAA6BF,GAA7B,EAAkCC,GAAlC,EAAuC,CAAvC,EAA0C,CAA1C,EAA6CE,IAApD;AACH;;;2CAEcH,G,EAAKC,G,EAAK;AACrB,uBAAO,KAAK/C,WAAL,CAAiBgD,YAAjB,CAA8BF,GAA9B,EAAmCC,GAAnC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8CE,IAArD;AACH;;;iDAEoBrB,O,EAAS;AAC1B,oBAAIC,GAAJ,EACIR,MADJ,EAEIS,CAFJ,EAGIC,IAHJ,EAIIC,IAJJ;;AAMAH,sBAAMjC,KAAKuB,MAAL,EAAN;AACAE,yBAASH,SAASU,QAAQF,CAAR,GAAY,KAAKV,SAAL,GAAkBa,GAAvC,EAA6C,EAA7C,CAAT;AACAC,oBAAI,KAAKnC,GAAL,GAAYkC,GAAhB;AACAE,uBAAOb,SAASU,QAAQJ,CAAR,GAAaH,SAASzB,KAAKqC,GAAL,CAASH,CAAT,CAA/B,EAA6C,EAA7C,CAAP;AACAE,uBAAOd,SAASU,QAAQH,CAAR,GAAaJ,SAASzB,KAAKsC,GAAL,CAASJ,CAAT,CAA/B,EAA6C,EAA7C,CAAP;;AAEA,oBAAIC,QAAQ,CAAR,IAAaA,QAAQ,KAAKjC,CAA9B,EAAiC;AAC7BiC,2BAAOb,SAASW,MAAM,KAAK/B,CAApB,EAAuB,EAAvB,CAAP;AACH;;AAED,oBAAIkC,QAAQ,CAAR,IAAaA,QAAQ,KAAKjC,CAA9B,EAAiC;AAC7BiC,2BAAOd,SAASW,MAAM,KAAK9B,CAApB,EAAuB,EAAvB,CAAP;AACH;;AAED,oBAAI,KAAKC,WAAL,KAAqB,IAAzB,EAA+B;AAC3BqB,6BAAS,KAAKN,SAAL,GAAkBnB,KAAKuB,MAAL,MAAiB,KAAKH,SAAL,GAAiB,KAAKD,SAAvC,CAA3B;AACH,iBAFD,MAEO;AACH;AACA,wBAAIO,IAAI,KAAKC,cAAL,CAAoBQ,IAApB,EAA0BC,IAA1B,CAAR;AACAX,6BAAS,KAAKN,SAAL,GAAkB,CAAC,KAAKC,SAAL,GAAiB,KAAKD,SAAvB,KAAqCO,EAAE,CAAF,IAAO,GAA5C,CAA3B;AACH;;AAED,uBAAO;AACHE,uBAAGO,IADA;AAEHN,uBAAGO,IAFA;AAGHN,uBAAGL;AAHA,iBAAP;AAKH;;;;;;YAGG/B,kB,GAAAA,kB","file":"poissonDisk.js","sourcesContent":["/**\n * Created by Thierry Hubmann\n * Ré-implémentation de la classe PoissonDisk implémentée par Marcel en ES2015 pour la rendre\n * compatible avec la nouvelle classe graphGenerationUtil.\n */\nclass PoissonDiskSampler {\n\n    constructor(width, height) {\n        // Coordonnées des points sur la surface\n        this.pointList = [];\n        // Nombre de points maximum sur la surface\n        this.maxPoints = 100;\n\n        this.pi2 = Math.PI * 2;\n        this.w = width;\n        this.h = height;\n        this.distanceMap = null;\n        this.excludeMap = null;\n        this.excludeThreshold = 0;\n\n        this.nr = 0;\n        this.pp = null;\n    }\n\n    /* créé un point au hasard\n     * @params radiusmin : rayon de la distance minimum\n     *         radiusmax : rayon de la distance maximum\n     *         type : nom de l'image. Ne sert pas au calcul des points\n     *         imgw : largeur de l'image. ne sert pas au calcul des points\n     *         imgh : hauteur de l'image. ne sert pas au calcul des points\n     * €returns\n     */\n    createPointsPerso(radiusmin, radiusmax, type, imgw, imgh) {\n        var numFailed = 0;\n        var maxFails = 500;\n        do {\n            if (this.nr === 0) { // Si aucun point n'existe on en créé un\n                this.pp = this.createfirstPointPerso(radiusmin, radiusmax, type, imgw, imgh);\n            } else { // Sinon on créé des points autour\n                this.pp = this.generateRandomAroundPerso(this.pp, radiusmin, radiusmax, type, imgw, imgh);\n            }\n            // sert à voir si le point en touche un autre\n            if (this.hitTest(this.pp)) {\n                this.pointList[this.nr] = this.pp;\n                this.nr++;\n                numFailed = 0;\n            } else {\n                numFailed++;\n            }\n        } while (numFailed > 0 && numFailed < maxFails);\n    }\n\n    /* créé le premier  point au hasard\n     * @params radiusmin : rayon de la distance minimum\n     *         radiusmax : rayon de la distance maximum\n     *         type : nom de l'image. Ne sert pas au calcul des points\n     *         imgw : largeur de l'image. ne sert pas au calcul des points\n     *         imgh : hauteur de l'image. ne sert pas au calcul des points\n     * €returns x : position x\n     *          y : position y\n     *          r : rayon de l'image\n     *          t : nom de l'image\n     *          w : largeur de l'image\n     *          h : hauteur de l'image\n     */\n    createfirstPointPerso(radiusMin, radiusMax, type, imgw, imgh) {\n        var ranX = parseInt(Math.random() * this.w, 10),\n            ranY = parseInt(Math.random() * this.h, 10),\n            radius;\n\n        if (this.distanceMap === null) {\n            radius = parseInt(radiusMin + (Math.random() * (radiusMax - radiusMin)), 10);\n        } else {\n            var p = this.getHitMapPixel(ranX, ranY);\n            radius = radiusMin + ((radiusMax - radiusMin) * (p[0] / 255));\n        }\n        return {x: ranX, y: ranY, r: radius, t: type, w: imgw, h: imgh};\n    }\n\n    /* créé un point au hasard\n     * @params radiusmin : rayon de la distance minimum\n     *         radiusmax : rayon de la distance maximum\n     *         type : nom de l'image. Ne sert pas au calcul des points\n     *         imgw : largeur de l'image. ne sert pas au calcul des points\n     *         imgh : hauteur de l'image. ne sert pas au calcul des points\n     * €returns x : position x\n     *          y : position y\n     *          r : rayon de l'image\n     *          t : nom de l'image\n     *          w : largeur de l'image\n     *          h : hauteur de l'image\n     */\n    generateRandomAroundPerso(p_point, radiusMin, radiusMax, type, imgw, imgh) {\n        var ran,\n            radius,\n            a,\n            newX,\n            newY;\n\n        ran = Math.random();\n        radius = parseInt(p_point.r + radiusMax * (ran), 10);\n        a = this.pi2 * (ran);\n        newX = parseInt(p_point.x + (radius * Math.sin(a)), 10);\n        newY = parseInt(p_point.y + (radius * Math.cos(a)), 10);\n\n        if (newX <= 0 || newX >= this.w) {\n            newX = parseInt(ran * this.w, 10);\n        }\n\n        if (newY <= 0 || newY >= this.h) {\n            newY = parseInt(ran * this.h, 10);\n        }\n\n        if (this.distanceMap === null) {\n            radius = radiusMin + (Math.random() * (radiusMax - radiusMin));\n        } else {\n            // red color\n            var p = this.getHitMapPixel(newX, newY);\n            radius = radiusMin + ((radiusMax - radiusMin) * (p[0] / 255));\n        }\n\n        return {\n            x: newX,\n            y: newY,\n            r: radius,\n            t: type,\n            w: imgw,\n            h: imgh\n        };\n    }\n\n    // créé un point au hasard sur la carte\n    createPoints() {\n        var nr = 0,\n            pp,\n            numFailed = 0;\n\n        while (nr < this.maxPoints && numFailed < this.maxFails) {\n            if (nr === 0) {\n                pp = this.createfirstPoint();\n            } else {\n                pp = this.generateRandomAround(pp);\n            }\n\n            if (this.hitTest(pp)) {\n                this.pointList[nr] = pp;\n                nr++;\n                numFailed = 0;\n            } else {\n                numFailed++;\n            }\n        }\n    }\n\n    // regarde si le point créé touche un autre point\n    hitTest(p_point) {\n        if (this.excludeMap !== null) {\n            var p = this.getExcludeMapPixel(p_point.x, p_point.y);\n            if (p[0] <= this.excludeThreshold) {\n                return false;\n            }\n        }\n\n        var l = this.pointList.length,\n            d = 0,\n            dx = 0,\n            dy = 0,\n            i = l,\n            pTemp;\n\n        if (l > 0) {\n            while (i--) {\n                pTemp = this.pointList[i];\n                dx = pTemp.x - p_point.x;\n                dy = pTemp.y - p_point.y;\n                d = Math.sqrt(dx * dx + dy * dy);\n\n                if (d <= (pTemp.r + p_point.r)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    createfirstPoint() {\n        var ranX = parseInt(Math.random() * this.w, 10),\n            ranY = parseInt(Math.random() * this.h, 10),\n            radius;\n\n        if (this.distanceMap === null) {\n            radius = parseInt(this.radiusMin + (Math.random() * (this.radiusMax - this.radiusMin)), 10);\n        } else {\n            var p = this.getHitMapPixel(ranX, ranY);\n            radius = this.radiusMin + ((this.radiusMax - this.radiusMin) * (p[0] / 255));\n        }\n        return {x: ranX, y: ranY, r: radius};\n    }\n\n    getExcludeMapPixel(p_x, p_y) {\n        return this.excludeMap.getImageData(p_x, p_y, 1, 1).data;\n    }\n\n    getHitMapPixel(p_x, p_y) {\n        return this.distanceMap.getImageData(p_x, p_y, 1, 1).data;\n    }\n\n    generateRandomAround(p_point) {\n        var ran,\n            radius,\n            a,\n            newX,\n            newY;\n\n        ran = Math.random();\n        radius = parseInt(p_point.r + this.radiusMax * (ran), 10);\n        a = this.pi2 * (ran);\n        newX = parseInt(p_point.x + (radius * Math.sin(a)), 10);\n        newY = parseInt(p_point.y + (radius * Math.cos(a)), 10);\n\n        if (newX <= 0 || newX >= this.w) {\n            newX = parseInt(ran * this.w, 10);\n        }\n\n        if (newY <= 0 || newY >= this.h) {\n            newY = parseInt(ran * this.h, 10);\n        }\n\n        if (this.distanceMap === null) {\n            radius = this.radiusMin + (Math.random() * (this.radiusMax - this.radiusMin));\n        } else {\n            // red color\n            var p = this.getHitMapPixel(newX, newY);\n            radius = this.radiusMin + ((this.radiusMax - this.radiusMin) * (p[0] / 255));\n        }\n\n        return {\n            x: newX,\n            y: newY,\n            r: radius\n        };\n    }\n}\n\nexport {PoissonDiskSampler};\n"]}